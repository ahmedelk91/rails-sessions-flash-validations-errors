# Validations

Flash is especially helpful for correcting the user when they use your app in the wrong way -- entering bogus data, for example.

## Framing (5 min)

In our Rails apps, we've been entering a lot of bogus data -- artists with blank names, for instance. That's fine while we're in development, but we don't want the users of our live app to be able to get away with that.

Q. Based on what we know, how could we prevent users from entering **blank data** into a field?
---

> A. Javascript.

...but that's easily circumvented with Chrome's Inspector.


> A. We could put that in the controller, like so:

```rb
# app/controllers/todos_controller.rb
def create
  if params[:todo][:author] == ""
    flash[:alert] = "Author can't be blank!"
    redirect_to @todo
  else
    @todo = Todo.create(todo_params)
    redirect_to @todo
  end
end
  ```

...but putting it in the controller is going to lead to some pretty unwieldy controller methods. Besides, we may want there to be several routes that create or update an artist, and we'd need to copy and paste that bit of code for each one. That's hardly DRY!

> A. We could put in database constraints, like `NOT NULL` and `UNIQUE`, by going and playing around in SQL.

But...it's SQL.  Rails provides [some helpers](http://edgeguides.rubyonrails.org/active_record_migrations.html#column-modifiers) for managing database constraints.  Beyond those, it can be difficult.

Wouldn't it be nice if, before an Artist record was saved, we could validate that the data entered into its fields were correct?

## You do (15 min)

[The docs, for reference.](http://guides.rubyonrails.org/active_record_validations.html)

- Add the following code to your Artist model. What does each line do?

```rb
class Artist < ActiveRecord::Base
  validates :name, presence: true
  validates :name, uniqueness: true
  validates :name, length: {in: 1..20}
  validates :nationality, inclusion: ["USA", "Canada", "UK"]
end
```

- What's the *un*-DRY version of the following?

```rb
class Artist < ActiveRecord::Base
  validates :name, :nationality, :photo_url, presence: true
  validates :name, uniqueness: true, length: {maximum: 100}
end
```

- Can you figure out what these would do?

```rb
class User < ActiveRecord::Base
  validates :password, confirmation: true
  validates :age, numericality: {only_integer: true, greater_than_or_equal_to: 13}
  validates :country, exclusion: ["North Korea"]
end
```

- What are the differences between the two following snippets?

```rb
class User < ActiveRecord::Base
  validates :password, confirmation: true
  validates :ssn, uniqueness: true, allow_blank: true
end

class User < ActiveRecord::Base
  validates :password, confirmation: true, on: create
  validates :ssn, uniqueness: true, allow_nil: true
end
```

## Custom validations (10 min)

You can also easily create your own custom validations. For instance, this will make Tunr reject any artist named Billy Ray Cyrus:

```rb
# app/models/artist.rb
class Artist < ActiveRecord::Base
  validate :break_billy_rays_achy_breaky_heart

  def break_billy_rays_achy_breaky_heart
    if self.name == "Billy Ray Cyrus"
      errors.add(:name, "cannot be Billy Ray Cyrus, because he doesn't qualify as an artist.")
    end
  end
end
```

Q. Test it out by using the form to create a new artist named "Billy Ray Cyrus". What does `errors.add` do?
---

> A. Determines what the error message is.

Q. This validation won't be triggered if the user writes "billy ray cyrus" in all-lowercase. How could you fix that?
---

> A. `if self.name.downcase == "billy ray cyrus"`

## Validation in the console (10 min)

Let's test out these validations in the Rails console.

You can leave `rails s` running in one tab; it doesn't matter. In a *different* tab, run `rails c`.

Your "prompt" in the Rails console should look something like this:

```
2.2.3 :001>
```

Now, type in:

```
$ billy = Artist.new(name: "Billy Ray Cyrus")
$ miley = Artist.new(name: "Miley Cyrus")
```

Q. What does `billy.valid?` do? What about `miley.valid?`
---

> A. Tells us whether these Artists will be able to be saved to the database.

Q. After typing `billy.valid?`, type `billy.errors`. What does it do? What about `billy.errors.full_messages`?
---

> A. Contains the error messages generated by trying to save the Artist.

These are the methods Rails uses underneath the surface to trigger validation errors.

Q. Imagine you see the below line of code has been added to the `views/artists/new.html.erb` page. What does it do?
---

```
<%= @artist.errors.full_messages.first if @artist.errors.any? %>
```

> A. It prints out the first error message that was generated.

### Validation triggers

If you only write these:

```
$ billy = Artist.new(name: "Billy Ray Cyrus")
$ billy.errors.full_messages
```
...you'll get a blank array. That's because `.new` doesn't actually make the validations happen. The only methods that *do* are:

```
.valid?
.save
.save!
.create
.create!
.update
.update!
```

...so `.errors.full_messages` must be run after these.

## Break (10 min)

## Bangin' methods (10 min)

Let's try using `.create` instead of `.new`:

```
$ billy = Artist.create(name: "Billy Ray Cyrus")
```

### Rollback

You should see something like:

```
2.2.1 :024 > billy = Artist.create(name: "Billy Ray Cyrus")
   (0.2ms)  BEGIN
   (0.6ms)  ROLLBACK
 => #<Artist id: nil, name: "Billy Ray Cyrus", photo_url: nil, nationality: nil, created_at: nil, updated_at: nil>
```

That `ROLLBACK` indicates that ActiveRecord tried running a SQL command, but it was unsuccessful, so it's undoing -- or "rolling-back" -- any changes that it made.

### With a bang

Now try the same command, but put a bang `!` at the end of `.create`:

```
$ billy = Artist.create!(name: "Billy Ray Cyrus")
```

Q. What's the difference between `.create` and `.create!`?
---

> A. Adding in a bang makes the app throw a fatal error -- that is, "break" -- if a validation fails. Without the bang, it fails "silently".

You can add a bang to both `.create` and `.save`.

## Using a boolean instead of the exception (10 min)

The discussion on validations has so far shown you about 18 different ways a user can "break" your app.

Truth be told, however, we don't usually use `.create` or `.create!` in Rails apps. Instead, we use `.new` and `.save`.

Q. What's the difference between `.create` and `.new / .save`?
---

> A. `.create` is the same thing as `.new` and `.save` run right after each other.

This gives us a way of making sure the user doesn't see a broken app:

```rb
# app/controllers/todos_controller.rb
def create
  @artist = Artist.new(artist_params)
  if @artist.save
    flash[:notice] = "#{@artist.name} was successfully created."
    redirect_to @artist
  else
    render :new
  end
end
```

...and in the form view:

```erb
<!-- app/views/todos/_form.html.erb -->
<%= @artist.errors.full_messages.first if @artist.errors.any? %>
<%= form_for @artist do |f| %>
```

This way, one thing happens when the user is successful -- and when they're *not* successful, something else happens and they're told what they did wrong.

### This ^ is the "right way" to write a Rails controller.

You could also do:

```erb
<!-- app/views/todos/_form.html.erb -->
<% @artist.errors.full_messages.each do |message| %>
  <p><%= message %></p>
<% end %>
```

### Pro (debugging) tip

Add `<%= debug(@artist) %>` to "app/views/todos/new.html.erb" to see information contained in `@artist`.  Try submitting invalid information for a new Artist.


## You do: Apply this to the artists#update action (10 min)

```rb
# app/controllers/todos_controller.rb
def update
  @artist = Artist.find(params[:id])
  if @artist.update(artist_params)
    flash[:notice] = "#{@artist.name} was created."
    redirect_to @artist
  else
    render :new
  end
end
```
---

## SimpleForm (10 min)

Ensure your Gemfile contains:
```
gem 'simple_form'
```

`bundle install`, and **restart the server**.

Change your `todos/_form.html.erb` form to use `simple_form_for`:

```erb
<!-- app/views/todos/_form.html.erb -->
<%= simple_form_for @artist do |f| %>
  <%= f.input :author %>
  <%= f.input :body %>
  <%= f.submit %>
<% end %>
```

Finally, make sure your Artist model has a validation in it.

Try creating a new Artist, making sure you fail that validation.

Pretty cool, huh?
---
